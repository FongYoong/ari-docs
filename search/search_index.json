{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ari , a simple interpreter messily written in Rust . \u00b6 \u23ec Download \ud83c\udfae Try it out now \ud83d\udcd6 Language features","title":"Home"},{"location":"#ari-a-simple-interpreter-messily-written-in-rust","text":"\u23ec Download \ud83c\udfae Try it out now \ud83d\udcd6 Language features","title":"Ari, a simple interpreter messily written in Rust."},{"location":"checklist/","text":"Compiled in one lonely executable Colored and helpful errors Variables Declaraction with let Assignment with = Automatic cloning References Block scoping Type bindings and resolving Logical operators == != > >= < <= and or Control flow Loops while for break continue if else switch / match / any matching patterns Literals Number String Booleans Null Arrays Functions Hashmaps Classes Functions Invocation Declarative functions Return values with return First-class property Closures Anonymous functions Built-in functions Print with print or println Exit with bai Many others... Arrays Access specific element Assign specific element Arithmetic String Number Logical operators Classes Methods Inheritance Polymorphism Interface Abstract class Modules","title":"Checklist"},{"location":"features/array/","text":"A Array is a collection or sequence of values of the following types: Number , String , Boolean , Null , Function , or Array . The array's elements must be of the same type . Declaration \u00b6 Below are valid arrays: 1 2 3 4 let a = [1, 2, 3]; // Array of Numbers let b = [\"abc\", \"def\"]; // Array of String let c = [true, false, true]; // Array of Booleans let d = []; // Array with zero elements and no particular type Arrays can be nested as deep as we like, as long as the types for each dimension are the same. The length of each nested array need not be the same. 1 2 3 let d = [[1, 2, 3], [9, 4], [5, 7, 3, 0.25]]; // 2D Array of Numbers let e = [[1, 2, 3, 4], [\"hoho\", \"haha\", \"hehe\"], [true, false]]; // 2D Array of mixed types let f = [[1, 2, 3], [[5, 5, 5], [8, 8, 8]], [true, false]]; // Multi-dimensional Array with mixed lengths Always check the elements' type: It cannot be emphasised enough that an array's elements must have the same type . However, arrays are allowed to contain nested arrays of different types , as demonstrated in the earlier examples. Access \u00b6 Add a pair of square brackets [...] and specify an index inside the brackets to access the index's value. The index of the first element is 0. Otherwise, the index must be a positive integer. 1 2 3 let a = [7, 8, 9]; println a[0]; // 7 println a[0] + a[1] + a[2]; // 24 Be careful with indexes: The index must be less than the array's length. Line 2 below yields an error because the index is out of bounds: 1 2 let a = [7, 8, 9]; // Array of length 3 with indexes 0, 1, and 2 println a[3]; // Error because index 3 does not exist in the array Assignment \u00b6 Similar syntax to accessing arrays and assigning variables . 1 2 3 let a = [1, 2, 3]; a[0] = 5; // Change first element to 5 println a; // [5, 2, 3] Again, be careful with indexes: The index must be less than the array's length. Line 2 below yields an error because the index is out of bounds: 1 2 let a = [7, 8, 9]; // Array of length 3 with indexes 0, 1, and 2 a[3] = 5; // Error because index 3 does not exist in the array Arithmetic \u00b6 Number Arrays \u00b6 Operator Description + Addition - Subtraction * Multiply / Divide Number arithmetic is applied element-wise, provided that: both arrays' elements are all Numbers both arrays have the same length/number of elements . Do not take arithmetic for granted: The line below yields an error due to different array lengths: 1 println [1, 2, 3] + [4, 5, 6, 7]; // Error due to different lengths Also, division by zero in any of the elements will result in an error. Example 1 REPL.IT Code only 1 2 3 4 5 6 7 8 let a = [1, 2, 3]; let b = [10, 20, 30]; let c = [5, 25, 0]; println a + b; // [11, 22, 33] println c - b; // [-5, 5, -30] println a * c; // [5, 50, 0] println a / b; // [0.1, 0.1, 0.1] println a / c; // Error due to division by zero at the 3rd element String Arrays \u00b6 Operator Description + Concatenation String concatenation is applied element-wise, provided that: both arrays' elements are all String both arrays have the same length/number of elements . 1 2 3 4 let a = [\"Sweet\", \"Hio\", \"Anal\"]; let b = [\" Home\", \" Hio\", \" swab\"]; let c = [\" Alabama\", \" Hio\", \" test\"]; println a + b + c; // [\"Sweet Home Alabama\", \"Hio Hio Hio\", \"Anal swab test\"] Logical comparisons \u00b6 Logical operators described in Number , String , and Boolean are not supported out-of-the-box for Arrays. We have to manually access each element and compare using loops or map . I apologize for my laziness . Built-in functions \u00b6 length \u00b6 length( Array ) \u279f Number Returns the Array 's length. insert \u00b6 insert(source: Array , index: Number , new_value: Array ) \u279f Array Inserts new_value into the Array at the index and returns the result. Example 1 println insert([5, 8, 9], 1, [6, 7]); // [5, 6, 7, 8, 9] Warning index must be a positive integer and within the length of the array. The elements of the inserted array must be of the same type as the source. remove \u00b6 remove(source: Array , index: Number ) \u279f Array Removes an element specified by the index from the source and returns the result. Example 1 println remove([5, 8, 9], 2); // [5, 8] Warning index must be a positive integer and within the length of the array. map \u00b6 map(source: Array , map_function: Function ) \u279f Array Transforms each element of the array using the given function and returns the result. The mapping function must have only one argument which represents the array's element. Example 1 2 3 4 fn do_something (a) { return (a - 5) / 100; } println map([5, 8, 9], do_something); // [0, 0.03, 0.04] Warning If the function returns different types of values, such as Number and String , the resulting array may contain elements of different types. Although this violates the Declaration criteria which requires elements to be of the same type, it is allowed for the sake of flexibility, but proceed at your own risk. filter \u00b6 filter(source: Array , filter_function: Function ) \u279f Array Each element of the array is fed into the filtering function which returns a Boolean . Each element is retained if the Boolean is true , and is excluded if false The filtering function must return a Boolean . The filtering function must have only one argument which represents the array's element. Example This example filters out elements greater-or-equal to 5: 1 2 3 4 fn less_than_5 (a) { return a < 5; } println filter([3, 8, 9, 5, 4], less_than_5); // [3, 4] reduce \u00b6 reduce(source: Array , initial_value: AnyType , reduce_function: Function ) \u279f AnyType At the start, the initial value and the first element of the array is fed into the reducing function which does something to the two values and returns a new value. This new value and the next array element are then fed into the reducing function, and the process repeats until the end of the array. The final resulting value is returned. The initial value must be of the same type as the array's elements. The filtering function must have only two arguments , the left argument represents the initial/previous value and the right argument represents the current element of the array. Example This example returns the sum of the first 10 integers. Note that the initial value is 0: 1 2 3 4 5 fn sum (a, b) { return a + b; } println reduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, sum); // 55 range \u00b6 range(start: Number , end: Number , step: Number ) \u279f Array Returns a Number array containing values within the specified start , end , and step . Example Example This example returns numbers between 1 to 3 with a step of 0.5: 1 2 println range(1, 3, 0.5); // [1, 1.5, 2, 2.5, 3] Warning The step cannot be zero unless the start and end are the same. If the numbers are increasing , the step must be positive . If the numbers are decreasing , the step must be negative . linspace \u00b6 linspace(start: Number , end: Number , number_of_elements: Number ) \u279f Array Returns a Number array containing values within the specified start , end , and number_of_elements . Obviously, the number of elements must be zero or positive. Example This example returns 5 numbers between 1 and 3: 1 2 println linspace(1, 3, 5); // [1, 1.5, 2, 2.5, 3] repeat \u00b6 repeat(value_to_repeat: AnyType , number_of_elements: Number ) \u279f Array Returns an array containing repeated copies of the same value. Obviously, the number of elements must be zero or positive. Example This example returns numbers between 1 to 3 with a step of 0.5: 1 2 println repeat(2.5, 1000); // 1000 values of 2.5 // [2.5, 2.5, 2.5, 2.5, ...]","title":"Array"},{"location":"features/array/#declaration","text":"Below are valid arrays: 1 2 3 4 let a = [1, 2, 3]; // Array of Numbers let b = [\"abc\", \"def\"]; // Array of String let c = [true, false, true]; // Array of Booleans let d = []; // Array with zero elements and no particular type Arrays can be nested as deep as we like, as long as the types for each dimension are the same. The length of each nested array need not be the same. 1 2 3 let d = [[1, 2, 3], [9, 4], [5, 7, 3, 0.25]]; // 2D Array of Numbers let e = [[1, 2, 3, 4], [\"hoho\", \"haha\", \"hehe\"], [true, false]]; // 2D Array of mixed types let f = [[1, 2, 3], [[5, 5, 5], [8, 8, 8]], [true, false]]; // Multi-dimensional Array with mixed lengths Always check the elements' type: It cannot be emphasised enough that an array's elements must have the same type . However, arrays are allowed to contain nested arrays of different types , as demonstrated in the earlier examples.","title":"Declaration"},{"location":"features/array/#access","text":"Add a pair of square brackets [...] and specify an index inside the brackets to access the index's value. The index of the first element is 0. Otherwise, the index must be a positive integer. 1 2 3 let a = [7, 8, 9]; println a[0]; // 7 println a[0] + a[1] + a[2]; // 24 Be careful with indexes: The index must be less than the array's length. Line 2 below yields an error because the index is out of bounds: 1 2 let a = [7, 8, 9]; // Array of length 3 with indexes 0, 1, and 2 println a[3]; // Error because index 3 does not exist in the array","title":"Access"},{"location":"features/array/#assignment","text":"Similar syntax to accessing arrays and assigning variables . 1 2 3 let a = [1, 2, 3]; a[0] = 5; // Change first element to 5 println a; // [5, 2, 3] Again, be careful with indexes: The index must be less than the array's length. Line 2 below yields an error because the index is out of bounds: 1 2 let a = [7, 8, 9]; // Array of length 3 with indexes 0, 1, and 2 a[3] = 5; // Error because index 3 does not exist in the array","title":"Assignment"},{"location":"features/array/#arithmetic","text":"","title":"Arithmetic"},{"location":"features/array/#number-arrays","text":"Operator Description + Addition - Subtraction * Multiply / Divide Number arithmetic is applied element-wise, provided that: both arrays' elements are all Numbers both arrays have the same length/number of elements . Do not take arithmetic for granted: The line below yields an error due to different array lengths: 1 println [1, 2, 3] + [4, 5, 6, 7]; // Error due to different lengths Also, division by zero in any of the elements will result in an error. Example 1 REPL.IT Code only 1 2 3 4 5 6 7 8 let a = [1, 2, 3]; let b = [10, 20, 30]; let c = [5, 25, 0]; println a + b; // [11, 22, 33] println c - b; // [-5, 5, -30] println a * c; // [5, 50, 0] println a / b; // [0.1, 0.1, 0.1] println a / c; // Error due to division by zero at the 3rd element","title":"Number Arrays"},{"location":"features/array/#string-arrays","text":"Operator Description + Concatenation String concatenation is applied element-wise, provided that: both arrays' elements are all String both arrays have the same length/number of elements . 1 2 3 4 let a = [\"Sweet\", \"Hio\", \"Anal\"]; let b = [\" Home\", \" Hio\", \" swab\"]; let c = [\" Alabama\", \" Hio\", \" test\"]; println a + b + c; // [\"Sweet Home Alabama\", \"Hio Hio Hio\", \"Anal swab test\"]","title":"String Arrays"},{"location":"features/array/#logical-comparisons","text":"Logical operators described in Number , String , and Boolean are not supported out-of-the-box for Arrays. We have to manually access each element and compare using loops or map . I apologize for my laziness .","title":"Logical comparisons"},{"location":"features/array/#built-in-functions","text":"","title":"Built-in functions"},{"location":"features/array/#length","text":"length( Array ) \u279f Number Returns the Array 's length.","title":"length"},{"location":"features/array/#insert","text":"insert(source: Array , index: Number , new_value: Array ) \u279f Array Inserts new_value into the Array at the index and returns the result. Example 1 println insert([5, 8, 9], 1, [6, 7]); // [5, 6, 7, 8, 9] Warning index must be a positive integer and within the length of the array. The elements of the inserted array must be of the same type as the source.","title":"insert"},{"location":"features/array/#remove","text":"remove(source: Array , index: Number ) \u279f Array Removes an element specified by the index from the source and returns the result. Example 1 println remove([5, 8, 9], 2); // [5, 8] Warning index must be a positive integer and within the length of the array.","title":"remove"},{"location":"features/array/#map","text":"map(source: Array , map_function: Function ) \u279f Array Transforms each element of the array using the given function and returns the result. The mapping function must have only one argument which represents the array's element. Example 1 2 3 4 fn do_something (a) { return (a - 5) / 100; } println map([5, 8, 9], do_something); // [0, 0.03, 0.04] Warning If the function returns different types of values, such as Number and String , the resulting array may contain elements of different types. Although this violates the Declaration criteria which requires elements to be of the same type, it is allowed for the sake of flexibility, but proceed at your own risk.","title":"map"},{"location":"features/array/#filter","text":"filter(source: Array , filter_function: Function ) \u279f Array Each element of the array is fed into the filtering function which returns a Boolean . Each element is retained if the Boolean is true , and is excluded if false The filtering function must return a Boolean . The filtering function must have only one argument which represents the array's element. Example This example filters out elements greater-or-equal to 5: 1 2 3 4 fn less_than_5 (a) { return a < 5; } println filter([3, 8, 9, 5, 4], less_than_5); // [3, 4]","title":"filter"},{"location":"features/array/#reduce","text":"reduce(source: Array , initial_value: AnyType , reduce_function: Function ) \u279f AnyType At the start, the initial value and the first element of the array is fed into the reducing function which does something to the two values and returns a new value. This new value and the next array element are then fed into the reducing function, and the process repeats until the end of the array. The final resulting value is returned. The initial value must be of the same type as the array's elements. The filtering function must have only two arguments , the left argument represents the initial/previous value and the right argument represents the current element of the array. Example This example returns the sum of the first 10 integers. Note that the initial value is 0: 1 2 3 4 5 fn sum (a, b) { return a + b; } println reduce([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, sum); // 55","title":"reduce"},{"location":"features/array/#range","text":"range(start: Number , end: Number , step: Number ) \u279f Array Returns a Number array containing values within the specified start , end , and step . Example Example This example returns numbers between 1 to 3 with a step of 0.5: 1 2 println range(1, 3, 0.5); // [1, 1.5, 2, 2.5, 3] Warning The step cannot be zero unless the start and end are the same. If the numbers are increasing , the step must be positive . If the numbers are decreasing , the step must be negative .","title":"range"},{"location":"features/array/#linspace","text":"linspace(start: Number , end: Number , number_of_elements: Number ) \u279f Array Returns a Number array containing values within the specified start , end , and number_of_elements . Obviously, the number of elements must be zero or positive. Example This example returns 5 numbers between 1 and 3: 1 2 println linspace(1, 3, 5); // [1, 1.5, 2, 2.5, 3]","title":"linspace"},{"location":"features/array/#repeat","text":"repeat(value_to_repeat: AnyType , number_of_elements: Number ) \u279f Array Returns an array containing repeated copies of the same value. Obviously, the number of elements must be zero or positive. Example This example returns numbers between 1 to 3 with a step of 0.5: 1 2 println repeat(2.5, 1000); // 1000 values of 2.5 // [2.5, 2.5, 2.5, 2.5, ...]","title":"repeat"},{"location":"features/boolean/","text":"A Boolean can be either true or false . Warning Arithmetic does not apply to Booleans . Cannot use Booleans with Number or String . Logical operators \u00b6 Operator Description Usage ! Negation ! Bool == Equal to Bool == Bool != Not equal to Bool != Bool and And Bool and Bool or Or Bool and Bool Info Logical comparisons return a Boolean . and or can be chained as many as we like: Bool and (Bool or Bool) and Bool or ... Warning Ordered comparisons such as > or < do not work for Booleans . Example REPL.IT Code only 1 2 3 4 5 println true == true; // true println true != false; // true println true and false; // false println true or false ; // true println true + false; // Error because Booleans cannot be added","title":"Boolean"},{"location":"features/boolean/#logical-operators","text":"Operator Description Usage ! Negation ! Bool == Equal to Bool == Bool != Not equal to Bool != Bool and And Bool and Bool or Or Bool and Bool Info Logical comparisons return a Boolean . and or can be chained as many as we like: Bool and (Bool or Bool) and Bool or ... Warning Ordered comparisons such as > or < do not work for Booleans . Example REPL.IT Code only 1 2 3 4 5 println true == true; // true println true != false; // true println true and false; // false println true or false ; // true println true + false; // Error because Booleans cannot be added","title":"Logical operators"},{"location":"features/builtin_functions/","text":"Essential \u00b6 print \u00b6 random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 println ; print \u00b6 random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...] bai \u00b6 random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...] Random generation \u00b6 random_choose \u00b6 random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...] random_normal \u00b6 random_normal(mean: Number , standard_deviation: Number , number_of_elements: Number ) \u279f Array A normal distribution is used to generate an array of random values using the mean and standard_deviation . The number of elements determine the length of the generated array and must be zero or positive. Example This example generates 1000 samples with zero mean and a standard deviation of 1: 1 2 println random_normal(0, 1, 1000); // 1000 random values // [0.3446016, -0.2162096, -0.8018565, 0.60348547, 0.42210117, ...] File operations \u00b6 read_file \u00b6 read_file(file_path: String ) \u279f Null Returns the contents of a file specified by the file path . If the file does not exist or cannot be read, Null is returned. Example This example introduces a simple error-handling pattern in case the file is not found: 1 2 3 4 5 6 7 let contents = read_file(\"myfile.txt\"); if (contents == null) { println \"Failed to read file!\"; } else { println \"Success!\"; } write_file \u00b6 write_file(file_path: String , data: String ) \u279f Number Writes data to a file specified by the file path . If the file does not exist, a new file will be created. Otherwise, the contents of an existing file will be overwritten. If everything goes as planned, the function will return 1. If an error occurs during the writing, the function will return 0. Example This example introduces a simple error-handling pattern in case the write operation fails: 1 2 3 4 5 6 7 let result = write_file(\"myfile.txt\", \"My passwords are ...\"); if (result == 0) { println \"Failed to write to file!\"; } else { println \"Success!\"; } Web stuff \u00b6 serve_static_folder \u00b6 serve_static_folder(folder_path: String , address: String , port: Number ) \u279f Nothing Starts a local web server which serves static files inside the given folder path . The most convenient address is \"localhost\" and the port must be a Number . Similar to how Express.js does it. More info here . Press Control-C to quit the server. Example This example starts a server at localhost:8000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 serve_static_folder(\"public\", \"localhost\", 8000); // Configured for staging. // => address: localhost // => port: 8000 // => log: normal // => workers: 16 // => secret key: generated // => limits: forms = 32KiB // => keep-alive: 5s // => read timeout: 5s // => write timeout: 5s // => tls: disabled // Mounting /: // => GET / [10] // => GET /<path..> [10] // Rocket has launched from http://localhost:8000 web_get \u00b6 web_get(url: String ) \u279f String Returns the response of a GET request from the given url . Returns Null if the request fails. Example This example sends a GET request to this website and writes the response to a new HTML file: 1 2 let content = web_get(\"http://www.blankwebsite.com/\"); write_file(\"blank.html\", content); web_post \u00b6 web_get(url: String , parameters: Array ) \u279f String Returns the response of a POST request from the given url . parameters must be an array of Strings ). The elements with even-numbered indexes (0, 2, 4, ...) are regarded as keys, whereas elements with odd-numbered indexes (1, 3, 5, ...) are regarded as values. Returns Null if the request fails. Example This example sends a POST request to this website with two parameters and writes the response to a response.txt file: 1 2 let content = web_post(\"http://httpbin.org/post\", [\"key1\", \"value1\", \"key2\", \"value2\"]); write_file(\"response.txt\", content); The contents of response.txt looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"args\": {}, \"data\": \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\", \"files\": {}, \"form\": {}, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"33\", \"Content-Type\": \"application/json\", \"Host\": \"httpbin.org\", \"X-Amzn-Trace-Id\": \"Root=1-6013ad21-1cf269b238720911742db09c\" }, \"json\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"origin\": \"219.95.127.175\", \"url\": \"http://httpbin.org/post\" } Lines 14 and 15 confirms that the website's server received our POST request successfully. ```","title":"Built-in Functions"},{"location":"features/builtin_functions/#essential","text":"","title":"Essential"},{"location":"features/builtin_functions/#print","text":"random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 println ;","title":"print"},{"location":"features/builtin_functions/#print_1","text":"random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...]","title":"print"},{"location":"features/builtin_functions/#bai","text":"random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...]","title":"bai"},{"location":"features/builtin_functions/#random-generation","text":"","title":"Random generation"},{"location":"features/builtin_functions/#random_choose","text":"random_choose(source: Array , number_of_elements: Number ) \u279f Array A uniform distribution is used to randomly select an element from the source . The number of elements determine the length of the generated array and must be zero or positive. Example This example simulates 1000 throws of a fair dice: 1 2 println random_choose([1, 2, 3, 4, 5, 6], 1000); // 1000 random values // [2, 3, 4, 5, 2, ...]","title":"random_choose"},{"location":"features/builtin_functions/#random_normal","text":"random_normal(mean: Number , standard_deviation: Number , number_of_elements: Number ) \u279f Array A normal distribution is used to generate an array of random values using the mean and standard_deviation . The number of elements determine the length of the generated array and must be zero or positive. Example This example generates 1000 samples with zero mean and a standard deviation of 1: 1 2 println random_normal(0, 1, 1000); // 1000 random values // [0.3446016, -0.2162096, -0.8018565, 0.60348547, 0.42210117, ...]","title":"random_normal"},{"location":"features/builtin_functions/#file-operations","text":"","title":"File operations"},{"location":"features/builtin_functions/#read_file","text":"read_file(file_path: String ) \u279f Null Returns the contents of a file specified by the file path . If the file does not exist or cannot be read, Null is returned. Example This example introduces a simple error-handling pattern in case the file is not found: 1 2 3 4 5 6 7 let contents = read_file(\"myfile.txt\"); if (contents == null) { println \"Failed to read file!\"; } else { println \"Success!\"; }","title":"read_file"},{"location":"features/builtin_functions/#write_file","text":"write_file(file_path: String , data: String ) \u279f Number Writes data to a file specified by the file path . If the file does not exist, a new file will be created. Otherwise, the contents of an existing file will be overwritten. If everything goes as planned, the function will return 1. If an error occurs during the writing, the function will return 0. Example This example introduces a simple error-handling pattern in case the write operation fails: 1 2 3 4 5 6 7 let result = write_file(\"myfile.txt\", \"My passwords are ...\"); if (result == 0) { println \"Failed to write to file!\"; } else { println \"Success!\"; }","title":"write_file"},{"location":"features/builtin_functions/#web-stuff","text":"","title":"Web stuff"},{"location":"features/builtin_functions/#serve_static_folder","text":"serve_static_folder(folder_path: String , address: String , port: Number ) \u279f Nothing Starts a local web server which serves static files inside the given folder path . The most convenient address is \"localhost\" and the port must be a Number . Similar to how Express.js does it. More info here . Press Control-C to quit the server. Example This example starts a server at localhost:8000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 serve_static_folder(\"public\", \"localhost\", 8000); // Configured for staging. // => address: localhost // => port: 8000 // => log: normal // => workers: 16 // => secret key: generated // => limits: forms = 32KiB // => keep-alive: 5s // => read timeout: 5s // => write timeout: 5s // => tls: disabled // Mounting /: // => GET / [10] // => GET /<path..> [10] // Rocket has launched from http://localhost:8000","title":"serve_static_folder"},{"location":"features/builtin_functions/#web_get","text":"web_get(url: String ) \u279f String Returns the response of a GET request from the given url . Returns Null if the request fails. Example This example sends a GET request to this website and writes the response to a new HTML file: 1 2 let content = web_get(\"http://www.blankwebsite.com/\"); write_file(\"blank.html\", content);","title":"web_get"},{"location":"features/builtin_functions/#web_post","text":"web_get(url: String , parameters: Array ) \u279f String Returns the response of a POST request from the given url . parameters must be an array of Strings ). The elements with even-numbered indexes (0, 2, 4, ...) are regarded as keys, whereas elements with odd-numbered indexes (1, 3, 5, ...) are regarded as values. Returns Null if the request fails. Example This example sends a POST request to this website with two parameters and writes the response to a response.txt file: 1 2 let content = web_post(\"http://httpbin.org/post\", [\"key1\", \"value1\", \"key2\", \"value2\"]); write_file(\"response.txt\", content); The contents of response.txt looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \"args\": {}, \"data\": \"{\\\"key1\\\":\\\"value1\\\",\\\"key2\\\":\\\"value2\\\"}\", \"files\": {}, \"form\": {}, \"headers\": { \"Accept\": \"*/*\", \"Content-Length\": \"33\", \"Content-Type\": \"application/json\", \"Host\": \"httpbin.org\", \"X-Amzn-Trace-Id\": \"Root=1-6013ad21-1cf269b238720911742db09c\" }, \"json\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"origin\": \"219.95.127.175\", \"url\": \"http://httpbin.org/post\" } Lines 14 and 15 confirms that the website's server received our POST request successfully. ```","title":"web_post"},{"location":"features/control_flow/","text":"Control flow is essential for implementing any computable algorithm. It dictates how the program should proceed from one step to another and enables it to have multiple paths. if \u00b6 if requires an expression which evaluates into a Boolean . This expression must be placed inside a pair of curved brackets: 1 if( expresssion ) An error occurs if the expression does not result in a Boolean 1 2 3 4 if(1 + 2) // Invalid because Number if(true != false) // Valid if(\"true\") // Invalid because String if(1 > 2) // Valid Lines 1 and 3 are invalid because their expressions do not result in a Boolean . A pair of curly brackets must be placed after the if to indicate a new block scope . The space inside the curly brackets has a new scope as explained here . 1 2 3 4 // Outer scope if (expression) { // Inner scope } Statements in the inner scope will only execute if the expression's Boolean is true . 1 2 3 4 5 6 7 8 9 10 11 let a = 90; if (a < 100) { // true a = a / 3; } if (a < 40) { // true a = (a + 20) / 10; } if (a < 5) { // false a = \"Success\"; } println a; // 5 else \u00b6 What if we want to do something else if the if expression is false ? Of course, we can add the negation operator to the expression: 1 2 3 4 5 6 7 8 let a = 5; let b = 10; if (a + b < 15) { // false println \"Less than 15\"; } if (!(a + b < 15)) { // Negation produces a true value println \"Not less than 15\"; // This gets printed } * The above approach would be tedious and makes the code look unnecessarily verbose. * The else keyword offers a shortcut for this: 1 2 3 4 5 6 7 8 let a = 5; let b = 10; if (a + b < 15) { // false println \"Less than 15\"; } else { // true println \"Not less than 15\"; // This gets printed } Warning Both if and else require the curly brackets and an error occurs if otherwise. Permitted in some popular languages, the syntax below is supported in Ari: 1 2 3 4 if (a + b < 15) println \"Less than 15\"; else println \"Not less than 15\"; // This gets printed The above syntax is not recommended because it can cause unexpected behaviour if used incorrectly. Apple's IOS had a security bug in 2014 that resulted because of this syntax being permitted in C++. More info here . while \u00b6 A while loop requires an expression and a body (curly brackets) just like if . The statements in its body are executed indefinitely until the expression is false . The program below has an \"infinite\" loop because it repeats without stopping: 1 2 3 4 5 let count = 1; while(true) { println count; // prints indefinitely count = count + 1; // increments the value of count } We can introduce a value check to bound the loop: 1 2 3 4 5 let count = 1; while(count <= 10) { // checks the value of count println count; // prints 1 to 10 count = count + 1; // increments the value of count } for \u00b6 A for loop follows the traditional format where we: declare or initialise a Variable . specify an expression which evaluates into a Boolean , just like in if and while . state how the Variable should be modified. separate the above three with semicolons ; Check out this example for a better understanding. The program below prints even numbers starting from 0 and lesser than 10 . 1 2 3 4 5 // outer scope for(let a = 0; a < 10; a = a + 2) { // inner scope println a; // 0 2 4 6 8 } let a = 0 declares a new variable a with the number zero. This variable 's scope is bound to the inner scope . a < 10 is checked at the beginning of every iteration. The loop stops when it is false . a = a + 2 modifies the variable a at the end of every iteration. Loop keywords \u00b6 There are two keywords relevant to loops: continue \u00b6 A continue keyword inside a loop will skip all the statements after it and move on to the next iteration. The program below does not print anything because `continue skips everything after it. 1 2 3 4 5 6 let count = 1; while(count <= 10) { continue; println count; // Skipped count = count + 1; // Skipped } The program below prints 1 to 10, but skips 5 due to the continue : 1 2 3 4 5 6 7 8 9 let count = 1; while(count <= 10) { if (count == 5) { count = count + 1; continue; } println count; // prints 1 2 3 4 6 7 8 9 10 count = count + 1; } break \u00b6 A break keyword inside a loop will exit the loop. The program below does not print anything because `break stops the loop. 1 2 3 4 5 6 let count = 1; while(count <= 10) { break; // Quits the loop in the first iteration println count; // Never executed at all, not even once count = count + 1; // Never executed at all, not even once } The program below prints 1 to 4: 1 2 3 4 5 6 7 8 9 let count = 1; while(count <= 10) { if (count == 5) { count = count + 1; break; } println count; // prints 1 2 3 4 count = count + 1; } Summary The main difference between continue and break is that: continue skips to the next iteration. break quits the loop entirely without considering the next iteration.","title":"Control Flow"},{"location":"features/control_flow/#if","text":"if requires an expression which evaluates into a Boolean . This expression must be placed inside a pair of curved brackets: 1 if( expresssion ) An error occurs if the expression does not result in a Boolean 1 2 3 4 if(1 + 2) // Invalid because Number if(true != false) // Valid if(\"true\") // Invalid because String if(1 > 2) // Valid Lines 1 and 3 are invalid because their expressions do not result in a Boolean . A pair of curly brackets must be placed after the if to indicate a new block scope . The space inside the curly brackets has a new scope as explained here . 1 2 3 4 // Outer scope if (expression) { // Inner scope } Statements in the inner scope will only execute if the expression's Boolean is true . 1 2 3 4 5 6 7 8 9 10 11 let a = 90; if (a < 100) { // true a = a / 3; } if (a < 40) { // true a = (a + 20) / 10; } if (a < 5) { // false a = \"Success\"; } println a; // 5","title":"if"},{"location":"features/control_flow/#else","text":"What if we want to do something else if the if expression is false ? Of course, we can add the negation operator to the expression: 1 2 3 4 5 6 7 8 let a = 5; let b = 10; if (a + b < 15) { // false println \"Less than 15\"; } if (!(a + b < 15)) { // Negation produces a true value println \"Not less than 15\"; // This gets printed } * The above approach would be tedious and makes the code look unnecessarily verbose. * The else keyword offers a shortcut for this: 1 2 3 4 5 6 7 8 let a = 5; let b = 10; if (a + b < 15) { // false println \"Less than 15\"; } else { // true println \"Not less than 15\"; // This gets printed } Warning Both if and else require the curly brackets and an error occurs if otherwise. Permitted in some popular languages, the syntax below is supported in Ari: 1 2 3 4 if (a + b < 15) println \"Less than 15\"; else println \"Not less than 15\"; // This gets printed The above syntax is not recommended because it can cause unexpected behaviour if used incorrectly. Apple's IOS had a security bug in 2014 that resulted because of this syntax being permitted in C++. More info here .","title":"else"},{"location":"features/control_flow/#while","text":"A while loop requires an expression and a body (curly brackets) just like if . The statements in its body are executed indefinitely until the expression is false . The program below has an \"infinite\" loop because it repeats without stopping: 1 2 3 4 5 let count = 1; while(true) { println count; // prints indefinitely count = count + 1; // increments the value of count } We can introduce a value check to bound the loop: 1 2 3 4 5 let count = 1; while(count <= 10) { // checks the value of count println count; // prints 1 to 10 count = count + 1; // increments the value of count }","title":"while"},{"location":"features/control_flow/#for","text":"A for loop follows the traditional format where we: declare or initialise a Variable . specify an expression which evaluates into a Boolean , just like in if and while . state how the Variable should be modified. separate the above three with semicolons ; Check out this example for a better understanding. The program below prints even numbers starting from 0 and lesser than 10 . 1 2 3 4 5 // outer scope for(let a = 0; a < 10; a = a + 2) { // inner scope println a; // 0 2 4 6 8 } let a = 0 declares a new variable a with the number zero. This variable 's scope is bound to the inner scope . a < 10 is checked at the beginning of every iteration. The loop stops when it is false . a = a + 2 modifies the variable a at the end of every iteration.","title":"for"},{"location":"features/control_flow/#loop-keywords","text":"There are two keywords relevant to loops:","title":"Loop keywords"},{"location":"features/control_flow/#continue","text":"A continue keyword inside a loop will skip all the statements after it and move on to the next iteration. The program below does not print anything because `continue skips everything after it. 1 2 3 4 5 6 let count = 1; while(count <= 10) { continue; println count; // Skipped count = count + 1; // Skipped } The program below prints 1 to 10, but skips 5 due to the continue : 1 2 3 4 5 6 7 8 9 let count = 1; while(count <= 10) { if (count == 5) { count = count + 1; continue; } println count; // prints 1 2 3 4 6 7 8 9 10 count = count + 1; }","title":"continue"},{"location":"features/control_flow/#break","text":"A break keyword inside a loop will exit the loop. The program below does not print anything because `break stops the loop. 1 2 3 4 5 6 let count = 1; while(count <= 10) { break; // Quits the loop in the first iteration println count; // Never executed at all, not even once count = count + 1; // Never executed at all, not even once } The program below prints 1 to 4: 1 2 3 4 5 6 7 8 9 let count = 1; while(count <= 10) { if (count == 5) { count = count + 1; break; } println count; // prints 1 2 3 4 count = count + 1; } Summary The main difference between continue and break is that: continue skips to the next iteration. break quits the loop entirely without considering the next iteration.","title":"break"},{"location":"features/examples/","text":"Estimating Pi, \u03c0 , with Monte Carlo \u00b6 Check out page 3 of this document (PDF) for more info. Increase the number of iterations or samples to obtain a more precise value. REPL.IT Code only 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let number_of_iterations = 25; let number_of_samples = 500; let radius = 200; let radius_squared = power(radius, 2); let sample_space = linspace(0, radius, 10000); let pi = 0; for(let i = 0; i < number_of_iterations; i = i + 1) { let x_array = random_choose(sample_space, number_of_samples); let y_array = random_choose(sample_space, number_of_samples); let count = 0; for(let k = 0; k < number_of_samples; k = k + 1) { let distance_squared = power(x_array[k], 2) + power(y_array[k], 2); if (distance_squared <= radius_squared) { // Inside circle count = count + 1; } } pi = pi + count / number_of_samples; println 4 * pi /number_of_iterations; } Using FFT for polynomial multiplication \u00b6 The Fast Fourier Transform (FFT) can be used to compute the resulting polynomial coefficients of a polynomial multiplication. For more info, refer to this StackExchange answer . REPL.IT Code only 1 Fibonacci (Slow) \u00b6 This implementation of the Fibonacci sequence is slow because it uses a recursive function, which results in many stack frames as explained here . REPL.IT Code only 1 2 3 4 5 6 7 8 9 10 fn fibonacci_slow(n) { if (n <= 1) { return n; } return fib(n - 2) + fib(n - 1); } for (let i = 0; i < 20; i = i + 1) { println fibonacci_slow(i); } Fibonacci (Fast) \u00b6 This implementation of the Fibonacci sequence is much faster than the previous example . REPL.IT Code only 1 2 3 4 5 6 7 8 let a = 0; let temp = 0; for (let b = 1; a < 10000; b = temp + b) { println a; temp = a; a = b; }","title":"Examples"},{"location":"features/examples/#estimating-pi-with-monte-carlo","text":"Check out page 3 of this document (PDF) for more info. Increase the number of iterations or samples to obtain a more precise value. REPL.IT Code only 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let number_of_iterations = 25; let number_of_samples = 500; let radius = 200; let radius_squared = power(radius, 2); let sample_space = linspace(0, radius, 10000); let pi = 0; for(let i = 0; i < number_of_iterations; i = i + 1) { let x_array = random_choose(sample_space, number_of_samples); let y_array = random_choose(sample_space, number_of_samples); let count = 0; for(let k = 0; k < number_of_samples; k = k + 1) { let distance_squared = power(x_array[k], 2) + power(y_array[k], 2); if (distance_squared <= radius_squared) { // Inside circle count = count + 1; } } pi = pi + count / number_of_samples; println 4 * pi /number_of_iterations; }","title":"Estimating Pi, \u03c0, with Monte Carlo"},{"location":"features/examples/#using-fft-for-polynomial-multiplication","text":"The Fast Fourier Transform (FFT) can be used to compute the resulting polynomial coefficients of a polynomial multiplication. For more info, refer to this StackExchange answer . REPL.IT Code only 1","title":"Using FFT for polynomial multiplication"},{"location":"features/examples/#fibonacci-slow","text":"This implementation of the Fibonacci sequence is slow because it uses a recursive function, which results in many stack frames as explained here . REPL.IT Code only 1 2 3 4 5 6 7 8 9 10 fn fibonacci_slow(n) { if (n <= 1) { return n; } return fib(n - 2) + fib(n - 1); } for (let i = 0; i < 20; i = i + 1) { println fibonacci_slow(i); }","title":"Fibonacci (Slow)"},{"location":"features/examples/#fibonacci-fast","text":"This implementation of the Fibonacci sequence is much faster than the previous example . REPL.IT Code only 1 2 3 4 5 6 7 8 let a = 0; let temp = 0; for (let b = 1; a < 10000; b = temp + b) { println a; temp = a; a = b; }","title":"Fibonacci (Fast)"},{"location":"features/function/","text":"A Function is a collection of statements or a block of code which can be run anytime and anywhere we like. Of course, anywhere implicitly assumes that the function is declared in the same scope or an outer scope, just like variables. Ari's functions are first class citizens , meaning that they can be stored in variables and passed around as arguments to other functions. Function names can only contain numbers , alphabets , and the underscore _ . Also, names cannot begin with a number; Declaration \u00b6 The fn keyword indicates the declaration of a new function. Declaration syntax must consist of: fn keyword functions's name a pair of curved brackets which represent's the function's arguments/parameters a pair of curly brackets which represent's the functions's scope 1 2 3 4 5 6 7 8 9 10 11 fn function_no_arguments() { println \"A\"; } fn function_1_argument(a) { println a / 10; } fn function_2_arguments(a, b) { println a + b; } Call/invoke the function by specifying the arguments inside a pair of curved brackets and placing them to the right of the function. 1 2 3 function_no_arguments(); function_1_argument(20); function_2_arguments(\"Good \", \"morning\"); We can redeclare the same function as many times as we like. 1 2 3 4 5 6 7 8 9 10 11 12 13 fn do_something() { println \"A\"; } fn do_something() { println \"B\"; } fn do_something() { println \"C\"; } do_something(); // Prints C return \u00b6 A return keyword quits the function and returns to where the function was last called. The program below does not print anything because return stops the loop. 1 2 3 4 5 fn hello() { return; println \"hello\"; } hello(); A Function can return any kind of value: 1 2 3 4 fn hello() { return \"Hello\"; } println hello(); For multiple return values, return an array instead: 1 2 3 4 5 6 7 fn hello() { let a = \"Hello\"; let b = \" there\"; return [a, b]; } let array_value = hello(); println array_value[0] + array_value[1]; Info If the function returns nothing, return is not required. 1 2 3 4 fn func() { // do something return; } should become: 1 2 3 fn func() { // do something } First class functions \u00b6 Functions can be stored inside variables: 1 2 3 4 5 fn add_two_numbers(a, b) { println a + b; } let my_variable = add_two_numbers; my_variable(10, 30); // Prints 40 Functions can also return other functions: 1 2 3 4 5 6 7 8 fn outer_function() { fn inner_function(a) { println a * 10; } return inner_function; } let my_function = outer_function(); my_function(7); // Prints 70 Closures \u00b6 First class functions keep a copy of their outer scope . This copy is cloned together with the function if it is assigned to other variables. The program below is a good demonstration of closures: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fn makeCounter(interval) { let interval = interval; let i = 0; fn count() { i = i + interval; println i; } return count; } let counter1 = makeCounter(1); counter1(); // \"1\" counter1(); // \"2\" counter1(); // \"3\" let counter5 = makeCounter(5); counter5(); // \"5\" counter5(); // \"10\" counter5(); // \"15\" let counter5_copy = counter5; counter5_copy(); // \"20\" counter5_copy(); // \"25\" counter5_copy(); // \"30\" counter5(); // \"20\" Line 1 declares a function makeCounter(interval) which returns a counter. This counter has access to the outer variable, i , because of the closure property. makeCounter(interval) offers the option to set the interval of the counter using the interval argument. Line 2 explicitly declares the interval argument in the closure so that the counter has access to it. Line 11 creates counter1 which has an interval of 1. Lines 12 to 14 prints 1, 2 and 3 respectively because the counter has an interval of 1. Line 16 creates counter5 which has an interval of 5. Lines 17 to 19 prints 5, 10 and 15 respectively because the counter has an interval of 5. Line 21 declares counter5_copy which is a copy of counter5 . Take note that the i of counter5 is 15 at this point. The closure property causes counter5_copy to also inherit an i of 15. Lines 22 to 24 prints 20, 25 and 30 respectively because counter5_copy starts from an i of 15. Line 26 prints 20 because the i of counter5 was 15 before this line was executed. Beware of undeclared closure variables: When returning a function, A , as a value from another function, B , we cannot expect A to capture the arguments of B automatically. Instead, we need to explicitly declare the argument in the closure so that A can inherit it. Refer to Line 2 of the previous example. The program below is similar to the previous example but Line 2 is commented out. 1 2 3 4 5 6 7 8 9 10 11 12 fn makeCounter(interval) { // let interval = interval; let i = 0; fn count() { i = i + interval; println i; } return count; } let counter5 = makeCounter(5); counter5(); // Error Line 12 results in an error shown below because count() cannot capture the interval argument:","title":"Function"},{"location":"features/function/#declaration","text":"The fn keyword indicates the declaration of a new function. Declaration syntax must consist of: fn keyword functions's name a pair of curved brackets which represent's the function's arguments/parameters a pair of curly brackets which represent's the functions's scope 1 2 3 4 5 6 7 8 9 10 11 fn function_no_arguments() { println \"A\"; } fn function_1_argument(a) { println a / 10; } fn function_2_arguments(a, b) { println a + b; } Call/invoke the function by specifying the arguments inside a pair of curved brackets and placing them to the right of the function. 1 2 3 function_no_arguments(); function_1_argument(20); function_2_arguments(\"Good \", \"morning\"); We can redeclare the same function as many times as we like. 1 2 3 4 5 6 7 8 9 10 11 12 13 fn do_something() { println \"A\"; } fn do_something() { println \"B\"; } fn do_something() { println \"C\"; } do_something(); // Prints C","title":"Declaration"},{"location":"features/function/#return","text":"A return keyword quits the function and returns to where the function was last called. The program below does not print anything because return stops the loop. 1 2 3 4 5 fn hello() { return; println \"hello\"; } hello(); A Function can return any kind of value: 1 2 3 4 fn hello() { return \"Hello\"; } println hello(); For multiple return values, return an array instead: 1 2 3 4 5 6 7 fn hello() { let a = \"Hello\"; let b = \" there\"; return [a, b]; } let array_value = hello(); println array_value[0] + array_value[1]; Info If the function returns nothing, return is not required. 1 2 3 4 fn func() { // do something return; } should become: 1 2 3 fn func() { // do something }","title":"return"},{"location":"features/function/#first-class-functions","text":"Functions can be stored inside variables: 1 2 3 4 5 fn add_two_numbers(a, b) { println a + b; } let my_variable = add_two_numbers; my_variable(10, 30); // Prints 40 Functions can also return other functions: 1 2 3 4 5 6 7 8 fn outer_function() { fn inner_function(a) { println a * 10; } return inner_function; } let my_function = outer_function(); my_function(7); // Prints 70","title":"First class functions"},{"location":"features/function/#closures","text":"First class functions keep a copy of their outer scope . This copy is cloned together with the function if it is assigned to other variables. The program below is a good demonstration of closures: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fn makeCounter(interval) { let interval = interval; let i = 0; fn count() { i = i + interval; println i; } return count; } let counter1 = makeCounter(1); counter1(); // \"1\" counter1(); // \"2\" counter1(); // \"3\" let counter5 = makeCounter(5); counter5(); // \"5\" counter5(); // \"10\" counter5(); // \"15\" let counter5_copy = counter5; counter5_copy(); // \"20\" counter5_copy(); // \"25\" counter5_copy(); // \"30\" counter5(); // \"20\" Line 1 declares a function makeCounter(interval) which returns a counter. This counter has access to the outer variable, i , because of the closure property. makeCounter(interval) offers the option to set the interval of the counter using the interval argument. Line 2 explicitly declares the interval argument in the closure so that the counter has access to it. Line 11 creates counter1 which has an interval of 1. Lines 12 to 14 prints 1, 2 and 3 respectively because the counter has an interval of 1. Line 16 creates counter5 which has an interval of 5. Lines 17 to 19 prints 5, 10 and 15 respectively because the counter has an interval of 5. Line 21 declares counter5_copy which is a copy of counter5 . Take note that the i of counter5 is 15 at this point. The closure property causes counter5_copy to also inherit an i of 15. Lines 22 to 24 prints 20, 25 and 30 respectively because counter5_copy starts from an i of 15. Line 26 prints 20 because the i of counter5 was 15 before this line was executed. Beware of undeclared closure variables: When returning a function, A , as a value from another function, B , we cannot expect A to capture the arguments of B automatically. Instead, we need to explicitly declare the argument in the closure so that A can inherit it. Refer to Line 2 of the previous example. The program below is similar to the previous example but Line 2 is commented out. 1 2 3 4 5 6 7 8 9 10 11 12 fn makeCounter(interval) { // let interval = interval; let i = 0; fn count() { i = i + interval; println i; } return count; } let counter5 = makeCounter(5); counter5(); // Error Line 12 results in an error shown below because count() cannot capture the interval argument:","title":"Closures"},{"location":"features/null/","text":"Null is a placeholder value to represent \"nothingness\". Warning Arithmetic does not apply to Null . Cannot use Null with Number or String . Logical operators \u00b6 Operator Description ! Not == Equal to != Not equal to and And or Or Info Logical operators are similar to that of Boolean . However, and and or will always return Null . Warning Ordered comparisons such as > or < do not work for Null . Example REPL.IT Code only 1 2 3 4 5 println null == null; // true println null != null; // false println null and null; // null println null or null ; // null println null == false; // Error because Null cannot be compared with Boolean","title":"Null"},{"location":"features/null/#logical-operators","text":"Operator Description ! Not == Equal to != Not equal to and And or Or Info Logical operators are similar to that of Boolean . However, and and or will always return Null . Warning Ordered comparisons such as > or < do not work for Null . Example REPL.IT Code only 1 2 3 4 5 println null == null; // true println null != null; // false println null and null; // null println null or null ; // null println null == false; // Error because Null cannot be compared with Boolean","title":"Logical operators"},{"location":"features/number/","text":"A Number is stored as a 32-bit float. Generally, no distinction is made between integers and floating-point values, except in some cases where integers are strictly required. Arithmetic \u00b6 Operator Description + Addition - Subtraction * Multiply / Divide Info Number can be added to String to produce a new String : 1 + \" Malaysia\" is equal to \"1 Malaysia\" Warning Division by zero will result in an error. Example 1 REPL.IT Code only 1 2 3 4 println 1 + 3 / 5; // 1.6 println 4 - 3 * (4 - 2 * (6 - 3)) / 3; // 6 println 0.99999 / 0.99999; // 1 println 1 / 0; // Division by zero error Logical comparisons \u00b6 Operator Description == Equal to != Not equal to > Greater >= Greater or equal to < Less than <= Less or equal to Info Logical comparisons return a Boolean . Example 2 REPL.IT Code only 1 2 3 4 5 println 1 == 1.0; // true println 2.999999 < 3; // true println 2.9999999 < 3; // false println 2.9999999 <= 3; // true println 2.9999999 > 3; // false Question From the example above, why is 2.999999 < 3 equal to true but 2.9999999 < 3 equal to false ? What does this demonstrate about Ari's floating-point numbers? Answer Ari's Number is stored as a 32-bit float, so its precision is limited. Built-in functions \u00b6 to_string \u00b6 to_string( Number ) \u279f String Converts Number to a String value power \u00b6 power(base: Number , power: Number ) \u279f Number Returns base ^ power log \u00b6 log(base: Number , value: Number ) \u279f Number Returns the logarithm of value with the given base Warning The program halts with this error if the log value is invalid (NaN or Inf): modulo \u00b6 modulo(value: Number , modulee: Number ) \u279f Number Returns the result of value modulo(%) modulee Warning Both value and modulee must be integers. Also, the modulee cannot be zero. absolute \u00b6 absolute( Number ) \u279f Number Returns the absolute value of the input floor \u00b6 floor( Number ) \u279f Number Returns the greatest integer less than or equal to the input ceiling \u00b6 ceiling( Number ) \u279f Number Returns the least integer greater than or equal to the input min \u00b6 min( Number , Number ) \u279f Number Returns the minimum of the two inputs max \u00b6 max( Number , Number ) \u279f Number Returns the maximum of the two inputs","title":"Number"},{"location":"features/number/#arithmetic","text":"Operator Description + Addition - Subtraction * Multiply / Divide Info Number can be added to String to produce a new String : 1 + \" Malaysia\" is equal to \"1 Malaysia\" Warning Division by zero will result in an error. Example 1 REPL.IT Code only 1 2 3 4 println 1 + 3 / 5; // 1.6 println 4 - 3 * (4 - 2 * (6 - 3)) / 3; // 6 println 0.99999 / 0.99999; // 1 println 1 / 0; // Division by zero error","title":"Arithmetic"},{"location":"features/number/#logical-comparisons","text":"Operator Description == Equal to != Not equal to > Greater >= Greater or equal to < Less than <= Less or equal to Info Logical comparisons return a Boolean . Example 2 REPL.IT Code only 1 2 3 4 5 println 1 == 1.0; // true println 2.999999 < 3; // true println 2.9999999 < 3; // false println 2.9999999 <= 3; // true println 2.9999999 > 3; // false Question From the example above, why is 2.999999 < 3 equal to true but 2.9999999 < 3 equal to false ? What does this demonstrate about Ari's floating-point numbers? Answer Ari's Number is stored as a 32-bit float, so its precision is limited.","title":"Logical comparisons"},{"location":"features/number/#built-in-functions","text":"","title":"Built-in functions"},{"location":"features/number/#to_string","text":"to_string( Number ) \u279f String Converts Number to a String value","title":"to_string"},{"location":"features/number/#power","text":"power(base: Number , power: Number ) \u279f Number Returns base ^ power","title":"power"},{"location":"features/number/#log","text":"log(base: Number , value: Number ) \u279f Number Returns the logarithm of value with the given base Warning The program halts with this error if the log value is invalid (NaN or Inf):","title":"log"},{"location":"features/number/#modulo","text":"modulo(value: Number , modulee: Number ) \u279f Number Returns the result of value modulo(%) modulee Warning Both value and modulee must be integers. Also, the modulee cannot be zero.","title":"modulo"},{"location":"features/number/#absolute","text":"absolute( Number ) \u279f Number Returns the absolute value of the input","title":"absolute"},{"location":"features/number/#floor","text":"floor( Number ) \u279f Number Returns the greatest integer less than or equal to the input","title":"floor"},{"location":"features/number/#ceiling","text":"ceiling( Number ) \u279f Number Returns the least integer greater than or equal to the input","title":"ceiling"},{"location":"features/number/#min","text":"min( Number , Number ) \u279f Number Returns the minimum of the two inputs","title":"min"},{"location":"features/number/#max","text":"max( Number , Number ) \u279f Number Returns the maximum of the two inputs","title":"max"},{"location":"features/overview/","text":"Make Ari come alive \u00b6 Once Ari is downloaded , either: double-click the file or open a command line in the same folder and enter ari-windows or ./ari-linux Ari's interface should look like this 1 2 3 4 5 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e Ari 0.1.0 _________ > Interpreter mode \u00b6 The above interface is called the interpreter mode or more commonly known as REPL . Experiment with Ari by typing in Ari-compatible syntax: Run a program \u00b6 For most practical purposes, it is better to write an Ari program in a separate file. For example, if the file's name is called even_numbers.ari , open the command line and enter ari-windows even_numbers.ari or ./ari-linux even_numbers.ari Below is a sample code for even_numbers.ari and the result: 1 2 3 for(let i = 0; i < 10; i = i + 2) { print i + \", \"; } Values \u00b6 Values are Ari's bread and butter: 1 2 3 4 5 1; // Number \"Good mourning\"; // String true; // Boolean [1, 2, 3]; // Array of Numbers [\"abc\", \"def\"]; // Array of Strings Check out the other sections for more info. Semicolon \u00b6 Never forget to add semicolons behind each statement. I know it is annoying, but consider it a mental discipline, like house chores. 1 2 3 1 + 2; 50 + 70 // Missing semicolon! 19 + 21; Whitespace \u00b6 Ari doesn't care about whitespace. How much spacing to use is up to you: 1 2 3 4 5 6 7 3; 2; 2; 3; 4; 1;1; 4; 5; 5; 6; 6; 7;7; \"I love whitespace\"; Comments \u00b6 Everyone loves to gossip, so comment to your heart's content by adding double slashes, // : 1 2 3 \"Shoplifters will be prostituted\"; // Note to self: Change this misspelling in one year's time when I review this code again. // Just kidding. Variable names \u00b6 Variable names can only contain numbers , alphabets , and the underscore _ . Also, names cannot begin with a number; 1 Displaying output \u00b6 Loops \u00b6 Exiting the program \u00b6 Arrays \u00b6 Generate random numbers \u00b6 Reading and writing to files \u00b6 No delete operations, because it's experimental, dont want people to lose their files Serve static files in a web server \u00b6 GET/POST Requests \u00b6","title":"Overview"},{"location":"features/overview/#make-ari-come-alive","text":"Once Ari is downloaded , either: double-click the file or open a command line in the same folder and enter ari-windows or ./ari-linux Ari's interface should look like this 1 2 3 4 5 \u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e Ari 0.1.0 _________ >","title":"Make Ari come alive"},{"location":"features/overview/#interpreter-mode","text":"The above interface is called the interpreter mode or more commonly known as REPL . Experiment with Ari by typing in Ari-compatible syntax:","title":"Interpreter mode"},{"location":"features/overview/#run-a-program","text":"For most practical purposes, it is better to write an Ari program in a separate file. For example, if the file's name is called even_numbers.ari , open the command line and enter ari-windows even_numbers.ari or ./ari-linux even_numbers.ari Below is a sample code for even_numbers.ari and the result: 1 2 3 for(let i = 0; i < 10; i = i + 2) { print i + \", \"; }","title":"Run a program"},{"location":"features/overview/#values","text":"Values are Ari's bread and butter: 1 2 3 4 5 1; // Number \"Good mourning\"; // String true; // Boolean [1, 2, 3]; // Array of Numbers [\"abc\", \"def\"]; // Array of Strings Check out the other sections for more info.","title":"Values"},{"location":"features/overview/#semicolon","text":"Never forget to add semicolons behind each statement. I know it is annoying, but consider it a mental discipline, like house chores. 1 2 3 1 + 2; 50 + 70 // Missing semicolon! 19 + 21;","title":"Semicolon"},{"location":"features/overview/#whitespace","text":"Ari doesn't care about whitespace. How much spacing to use is up to you: 1 2 3 4 5 6 7 3; 2; 2; 3; 4; 1;1; 4; 5; 5; 6; 6; 7;7; \"I love whitespace\";","title":"Whitespace"},{"location":"features/overview/#comments","text":"Everyone loves to gossip, so comment to your heart's content by adding double slashes, // : 1 2 3 \"Shoplifters will be prostituted\"; // Note to self: Change this misspelling in one year's time when I review this code again. // Just kidding.","title":"Comments"},{"location":"features/overview/#variable-names","text":"Variable names can only contain numbers , alphabets , and the underscore _ . Also, names cannot begin with a number; 1","title":"Variable names"},{"location":"features/overview/#displaying-output","text":"","title":"Displaying output"},{"location":"features/overview/#loops","text":"","title":"Loops"},{"location":"features/overview/#exiting-the-program","text":"","title":"Exiting the program"},{"location":"features/overview/#arrays","text":"","title":"Arrays"},{"location":"features/overview/#generate-random-numbers","text":"","title":"Generate random numbers"},{"location":"features/overview/#reading-and-writing-to-files","text":"No delete operations, because it's experimental, dont want people to lose their files","title":"Reading and writing to files"},{"location":"features/overview/#serve-static-files-in-a-web-server","text":"","title":"Serve static files in a web server"},{"location":"features/overview/#getpost-requests","text":"","title":"GET/POST Requests"},{"location":"features/string/","text":"A String is a sequence of characters or symbols with a dynamic length. Arithmetic \u00b6 Operator Description + Concatenation Info Concatenation is the merging of two or more Strings to produce a larger combined String . Number can be added to String to produce a new String : 1 + \" Malaysia\" is equal to \"1 Malaysia\" Logical comparisons \u00b6 Operator Description == Equal to != Not equal to Info Logical comparisons return a Boolean . Warning String cannot be logically compared with Number . We will need to convert the String to Number or vice versa. Ordered comparisons such as > or < do not work for String . For length comparisons, use the length() function to get the String's length which can then be compared numerically. Example REPL.IT Code only 1 2 3 4 5 println \"abc\" == \"def\"; // false println \"abc\" == \"abc\"; // true println \"abc\" + \"def\"; // \"abcdef\" println \"abc\" + 123; // \"abc123\" println \"abc\" - \"def\"; // Error because Strings cannot be subtracted Built-in functions \u00b6 length \u00b6 length( String ) \u279f Number Returns the String 's length. to_number \u00b6 to_number( String ) \u279f Number Converts String to a Number value and returns it Example 1 println to_number(\"3.142\"); // 3.142 Warning Warning String must be a valid integer or floating point number. Otherwise, the program halts with this error: split \u00b6 split(source: String , delimiter: String ) \u279f Array[ String ] Splits the source into a String Array according to a delimiter and returns the Array Example 1 2 println split(\"hey, there, whatchu, doing\", \",\"); // [\"hey\", \"there\", \"whatchu\", \"doing\"] insert \u00b6 insert(source: String , index: Number , new_value: String ) \u279f Array[ String ] Inserts new_value into the source at the index and returns the result Example 1 println insert(\"arna\", 2, \"ia\"); // \"ariana\" Warning index must be a positive integer and within the length of the array. Otherwise, the program halts with either of these errors: remove \u00b6 remove(source: String , index: Number ) \u279f String Removes a character specified by the index from the source and returns the result Example 1 println remove(\"ariana\", 2); // \"arana\" Warning index must be a positive integer and within the length of the array. Otherwise, the program halts with either of these errors: to_lowercase \u00b6 to_lowercase( String ) \u279f String Returns a lowercased version of the input String to_uppercase \u00b6 to_uppercase( String ) \u279f String Returns a uppercased version of the input String","title":"String"},{"location":"features/string/#arithmetic","text":"Operator Description + Concatenation Info Concatenation is the merging of two or more Strings to produce a larger combined String . Number can be added to String to produce a new String : 1 + \" Malaysia\" is equal to \"1 Malaysia\"","title":"Arithmetic"},{"location":"features/string/#logical-comparisons","text":"Operator Description == Equal to != Not equal to Info Logical comparisons return a Boolean . Warning String cannot be logically compared with Number . We will need to convert the String to Number or vice versa. Ordered comparisons such as > or < do not work for String . For length comparisons, use the length() function to get the String's length which can then be compared numerically. Example REPL.IT Code only 1 2 3 4 5 println \"abc\" == \"def\"; // false println \"abc\" == \"abc\"; // true println \"abc\" + \"def\"; // \"abcdef\" println \"abc\" + 123; // \"abc123\" println \"abc\" - \"def\"; // Error because Strings cannot be subtracted","title":"Logical comparisons"},{"location":"features/string/#built-in-functions","text":"","title":"Built-in functions"},{"location":"features/string/#length","text":"length( String ) \u279f Number Returns the String 's length.","title":"length"},{"location":"features/string/#to_number","text":"to_number( String ) \u279f Number Converts String to a Number value and returns it Example 1 println to_number(\"3.142\"); // 3.142 Warning Warning String must be a valid integer or floating point number. Otherwise, the program halts with this error:","title":"to_number"},{"location":"features/string/#split","text":"split(source: String , delimiter: String ) \u279f Array[ String ] Splits the source into a String Array according to a delimiter and returns the Array Example 1 2 println split(\"hey, there, whatchu, doing\", \",\"); // [\"hey\", \"there\", \"whatchu\", \"doing\"]","title":"split"},{"location":"features/string/#insert","text":"insert(source: String , index: Number , new_value: String ) \u279f Array[ String ] Inserts new_value into the source at the index and returns the result Example 1 println insert(\"arna\", 2, \"ia\"); // \"ariana\" Warning index must be a positive integer and within the length of the array. Otherwise, the program halts with either of these errors:","title":"insert"},{"location":"features/string/#remove","text":"remove(source: String , index: Number ) \u279f String Removes a character specified by the index from the source and returns the result Example 1 println remove(\"ariana\", 2); // \"arana\" Warning index must be a positive integer and within the length of the array. Otherwise, the program halts with either of these errors:","title":"remove"},{"location":"features/string/#to_lowercase","text":"to_lowercase( String ) \u279f String Returns a lowercased version of the input String","title":"to_lowercase"},{"location":"features/string/#to_uppercase","text":"to_uppercase( String ) \u279f String Returns a uppercased version of the input String","title":"to_uppercase"},{"location":"features/variable/","text":"A Variable is a reference to a block of memory containing any one of the literals: either Number , String , Boolean , Null , Function , or Array . The block of memory is dynamically allocated and deallocated automatically using both the stack and heap. Variable names can only contain numbers , alphabets , and the underscore _ . Also, names cannot begin with a number; Declaration \u00b6 The let keyword indicates the declaration of a new variable. Declaration syntax must consist of: let keyword variable's name equal symbol, = initial value of the variable 1 2 let a = 1; println a; // 1 We can redeclare the same variable as many times as we like. 1 2 3 4 5 6 let a = 1; println a; // 1 let a = 2; println a; // 2 let a = 3; println a; // 3 Assignment \u00b6 let is only used to declare a new Variable . Exclude it to mutate or change the value of an existing Variable : 1 2 3 let a = 1; a = 2; // Assign value 2 to a println a; // 2 Always declare variables first before assigning values 1 2 3 let b = 1; a = 2; // Error! println a + b; Next, we try changing a to b in Line 1 . Line 2 results in an error because a is an undeclared variable. The program halts with the error below: Block scoping and shadowing \u00b6 The space inside a pair of curly braces, {...} , has a new \"inner scope\", which is something like a fresh new environment. Scopes can be created and nested as many times as we like: 1 2 3 4 5 6 7 8 9 10 // Outer scope { // 1st inner scope { // 2nd inner scope { // 3rd inner scope } } } Variables declared inside an inner scope can access variables from outer scopes. 1 2 3 4 5 6 7 8 9 10 11 let a = 2; { { let b = 5; { { println a + b; // 7 } } } } Variables declared inside an inner scope shadows the outer scopes' variables of the same name. Shadowing is temporarily using a new representation/value of a variable. Once the inner scope ends, the previous/original/old value of the outer scope is restored to the variable. Again, this only occurs when the inner and outer variables share the same name . To understand this better, let us deconstruct the program below line by line 1 2 3 4 5 6 7 8 9 10 11 12 13 // Global scope let a = 1; { // Outer scope let a = 2; { // Inner scope let a = 3; println a; // 3 } println a; // 2 } println a; // 1 Line 1 declares a variable a with a value of 1 in the global scope. Line 5 declares a with a value of 2 in the outer scope. This value shadows the global scope's value of a . Line 8 declares a with a value of 3 in the inner scope. This value shadows the outer scope's value of a . The printed values follow the order of 1 2 3 . Beware of scoping pitfalls 1 2 3 4 5 6 7 8 9 10 11 12 13 // Global scope // let a = 1; { // Outer scope let a = 2; { // Inner scope let a = 3; println a; // 3 } println a; // 2 } println a; // 1 Next, we try commenting out Line 2 . Line 13 results in an error because a is only declared in the outer and inner scope, not the global scope. The program halts with the error below: Thought bubble 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let a = \"global a\"; let b = \"global b\"; let c = \"global c\"; { let a = \"outer a\"; let b = \"outer b\"; { let a = \"inner a\"; println a; // inner a println b; // outer b println c; // global c } println a; // outer a println b; // outer b println c; // global c } println a; // global a println b; // global b println c; // global c Ari's outputs are shown in the highlighted comments. Do you agree with the output? Let me know if you disagree.","title":"Variable"},{"location":"features/variable/#declaration","text":"The let keyword indicates the declaration of a new variable. Declaration syntax must consist of: let keyword variable's name equal symbol, = initial value of the variable 1 2 let a = 1; println a; // 1 We can redeclare the same variable as many times as we like. 1 2 3 4 5 6 let a = 1; println a; // 1 let a = 2; println a; // 2 let a = 3; println a; // 3","title":"Declaration"},{"location":"features/variable/#assignment","text":"let is only used to declare a new Variable . Exclude it to mutate or change the value of an existing Variable : 1 2 3 let a = 1; a = 2; // Assign value 2 to a println a; // 2 Always declare variables first before assigning values 1 2 3 let b = 1; a = 2; // Error! println a + b; Next, we try changing a to b in Line 1 . Line 2 results in an error because a is an undeclared variable. The program halts with the error below:","title":"Assignment"},{"location":"features/variable/#block-scoping-and-shadowing","text":"The space inside a pair of curly braces, {...} , has a new \"inner scope\", which is something like a fresh new environment. Scopes can be created and nested as many times as we like: 1 2 3 4 5 6 7 8 9 10 // Outer scope { // 1st inner scope { // 2nd inner scope { // 3rd inner scope } } } Variables declared inside an inner scope can access variables from outer scopes. 1 2 3 4 5 6 7 8 9 10 11 let a = 2; { { let b = 5; { { println a + b; // 7 } } } } Variables declared inside an inner scope shadows the outer scopes' variables of the same name. Shadowing is temporarily using a new representation/value of a variable. Once the inner scope ends, the previous/original/old value of the outer scope is restored to the variable. Again, this only occurs when the inner and outer variables share the same name . To understand this better, let us deconstruct the program below line by line 1 2 3 4 5 6 7 8 9 10 11 12 13 // Global scope let a = 1; { // Outer scope let a = 2; { // Inner scope let a = 3; println a; // 3 } println a; // 2 } println a; // 1 Line 1 declares a variable a with a value of 1 in the global scope. Line 5 declares a with a value of 2 in the outer scope. This value shadows the global scope's value of a . Line 8 declares a with a value of 3 in the inner scope. This value shadows the outer scope's value of a . The printed values follow the order of 1 2 3 . Beware of scoping pitfalls 1 2 3 4 5 6 7 8 9 10 11 12 13 // Global scope // let a = 1; { // Outer scope let a = 2; { // Inner scope let a = 3; println a; // 3 } println a; // 2 } println a; // 1 Next, we try commenting out Line 2 . Line 13 results in an error because a is only declared in the outer and inner scope, not the global scope. The program halts with the error below: Thought bubble 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let a = \"global a\"; let b = \"global b\"; let c = \"global c\"; { let a = \"outer a\"; let b = \"outer b\"; { let a = \"inner a\"; println a; // inner a println b; // outer b println c; // global c } println a; // outer a println b; // outer b println c; // global c } println a; // global a println b; // global b println c; // global c Ari's outputs are shown in the highlighted comments. Do you agree with the output? Let me know if you disagree.","title":"Block scoping and shadowing"},{"location":"setup/download/","text":"Platform Link Windows \u2b50 Download Linux \u2b50 Download Tip Windows The first time you start Ari, Windows Defender may scan the file for a few seconds before running it. Chrome or Microsoft Edge may warn about the file because it is \"uncommonly downloaded\". Before jumping to conclusions, you can always scan the file with VirusTotal . Linux Execute chmod +x ari-linux if permission error is encountered. Building from source \u00b6 This section is for those want to experiment with Ari's source code. General steps Clone Ari's repository \ud83d\udc6a git clone https://github.com/FongYoong/ari-lang.git Install the Rust toolchains (Rustc, Rustup, Cargo). Follow instructions here . Install nightly Rust with: rustup toolchain install nightly Move into the cloned repository cd ari-lang Configure the project to use nightly Rust: rustup override set nightly Build! \ud83d\udd28 cargo build --release Condensed instructions Windows 1 git clone https://github.com/FongYoong/ari-lang.git Install Rust: 32-bit or 64-bit 3 4 5 6 rustup toolchain install nightly cd ari-lang rustup override set nightly cargo build --release Linux 1 2 3 4 5 6 7 git clone https://github.com/FongYoong/ari-lang.git curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh source $HOME/.cargo/env rustup toolchain install nightly cd ari-lang rustup override set nightly cargo build --release","title":"Download"},{"location":"setup/download/#building-from-source","text":"This section is for those want to experiment with Ari's source code. General steps Clone Ari's repository \ud83d\udc6a git clone https://github.com/FongYoong/ari-lang.git Install the Rust toolchains (Rustc, Rustup, Cargo). Follow instructions here . Install nightly Rust with: rustup toolchain install nightly Move into the cloned repository cd ari-lang Configure the project to use nightly Rust: rustup override set nightly Build! \ud83d\udd28 cargo build --release Condensed instructions Windows 1 git clone https://github.com/FongYoong/ari-lang.git Install Rust: 32-bit or 64-bit 3 4 5 6 rustup toolchain install nightly cd ari-lang rustup override set nightly cargo build --release Linux 1 2 3 4 5 6 7 git clone https://github.com/FongYoong/ari-lang.git curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh source $HOME/.cargo/env rustup toolchain install nightly cd ari-lang rustup override set nightly cargo build --release","title":"Building from source"},{"location":"setup/try/","text":"Try It Out \u00b6 Editor \u00b6 Guide \u00b6 Keep the default False to run the Ari program. Change False to True if you want to manually key in Ari code in the command line. Type an Ari program in the red box ( 2 ) shown above. Click Run or the \u25b6 button to run the Ari program. You should see an output like below: Unfortunately, you'll need to sign in to edit and run the code. repl.it does not have direct support for custom language integration, so I had to configure Python to run Ari and show it on the command line.","title":"Try it out"},{"location":"setup/try/#try-it-out","text":"","title":"Try It Out"},{"location":"setup/try/#editor","text":"","title":"Editor"},{"location":"setup/try/#guide","text":"Keep the default False to run the Ari program. Change False to True if you want to manually key in Ari code in the command line. Type an Ari program in the red box ( 2 ) shown above. Click Run or the \u25b6 button to run the Ari program. You should see an output like below: Unfortunately, you'll need to sign in to edit and run the code. repl.it does not have direct support for custom language integration, so I had to configure Python to run Ari and show it on the command line.","title":"Guide"}]}